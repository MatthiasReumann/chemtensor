from sympy import S, sqrt, Matrix
from sympy.physics.wigner import racah
import re
from os.path import basename


def su2_j3_range(j1: int, j2: int):
    """
    Range of the combined quantum number 'j3' for given 'j1' and 'j2'.

    Quantum numbers are represented times 2 to support half-integers without rounding errors.
    """
    return range(abs(j1 - j2), j1 + j2 + 1, 2)


def js_range(ja: int, jb: int, jc: int):
    """
    Admissible range of quantum number combined from 'ja', 'jb', 'jc'.
    """
    js_min = min(abs(ja + jb - jc), abs(jc + ja - jb), abs(jb + jc - ja))
    js_max = ja + jb + jc
    return range(js_min, js_max + 1, 2)


def recoupling_matrix(ja: int, jb: int, jc: int, js: int):
    """
    Evaluate the SU(2) recoupling matrix for given 'j' quantum numbers.
    """
    jab_range = su2_j3_range(ja, jb)
    jbc_range = su2_j3_range(jb, jc)
    jas_range = su2_j3_range(ja, js)
    jcs_range = su2_j3_range(jc, js)
    je_range = sorted(list(set(jab_range) & set(jcs_range)))
    jf_range = sorted(list(set(jbc_range) & set(jas_range)))
    # jc <-> js flipped in function call due to convention
    return Matrix([[sqrt((je + 1) * (jf + 1)) * racah(S(ja)/2, S(jb)/2, S(js)/2, S(jc)/2, S(je)/2, S(jf)/2)
            for jf in jf_range]
            for je in je_range])


def convert_to_c_brackets(expr: str):
    """
    Convert Python square to C curly brackets.
    """
    return re.sub(r"\]", r" }", re.sub(r"\[", r"{ ", expr))


def generate_su2_recoupling_tables():

    hfile = open("su2_recoupling.h", "w")
    cfile = open("su2_recoupling.c", "w")

    hfile.write("/// \\file su2_recoupling.h\n")
    hfile.write("/// \\brief SU(2) recoupling coefficient tables.\n")
    hfile.write("///\n")
    hfile.write("/// 'j' quantum numbers are represented times 2, to support half-integers.\n")
    hfile.write("///\n")
    hfile.write("/// This file has been generated by '" + basename(__file__) + "'.\n")
    hfile.write("\n")
    hfile.write("#pragma once\n")
    hfile.write("\n")
    hfile.write("#include \"qnumber.h\"\n")
    hfile.write("\n")

    cfile.write("/// \\file su2_recoupling.c\n")
    cfile.write("/// \\brief SU(2) recoupling coefficient tables.\n")
    cfile.write("///\n")
    cfile.write("/// This file has been generated by '" + basename(__file__) + "'.\n")
    cfile.write("\n")
    cfile.write("#include <stdlib.h>\n")
    cfile.write("#include <assert.h>\n")
    cfile.write("#include \"su2_recoupling.h\"\n")
    cfile.write("#include \"util.h\"\n")
    cfile.write("\n")
    cfile.write("\n")

    num_ja = 5
    num_jb = 5
    num_jc = 5

    cfile.write("// format: su2_recoupling_ja_jb_jc_js[n][n]\n")
    for ja in range(num_ja):
        for jb in range(num_jb):
            for jc in range(num_jc):
                for js in js_range(ja, jb, jc):
                    mat = recoupling_matrix(ja, jb, jc, js)
                    shape = mat.shape
                    # must be a square matrix
                    assert shape[0] == shape[1]
                    mat = [[mat[i, j].evalf(n=17, strict=True) for j in range(shape[1])] for i in range(shape[0])]
                    expr = (f"static const double su2_recoupling_{ja}_{jb}_{jc}_{js}[{shape[0]}][{shape[1]}] = "
                            + convert_to_c_brackets(str(mat))
                            + ";\n")
                    cfile.write(expr)
    cfile.write("\n")

    num_js = (num_ja - 1) + (num_jb - 1) + (num_jc - 1) + 1
    cfile.write("// format: su2_recoupling_table[ja][jb][jc][js], points to orthogonal matrix of recoupling coefficients\n")
    cfile.write(f"static const double* su2_recoupling_table[{num_ja}][{num_jb}][{num_jc}][{num_js}] = {{ ")
    for ja in range(num_ja):
        cfile.write("{ ")
        for jb in range(num_jb):
            cfile.write("{ ")
            for jc in range(num_jc):
                cfile.write("{ ")
                for js in range(num_js):
                    if js in js_range(ja, jb, jc):
                        cfile.write(f"(const double*)su2_recoupling_{ja}_{jb}_{jc}_{js}, ")
                    else:
                        cfile.write("NULL, ")
                cfile.write("}, ")
            cfile.write("}, ")
        cfile.write("}, ")
    cfile.write("};\n")

    hfile.write("\n")
    hfile.write("double su2_recoupling_coefficient(const qnumber ja, const qnumber jb, const qnumber jc, const qnumber js, const qnumber je, const qnumber jf);\n")

    cfile.write(
rf"""

//________________________________________________________________________________________________________________________
///
/// \brief Retrieve the SU(2) recoupling coefficient for the provided 'j' quantum numbers (represented times 2).
///
double su2_recoupling_coefficient(const qnumber ja, const qnumber jb, const qnumber jc, const qnumber js, const qnumber je, const qnumber jf)
{{
	if ((ja + jb + jc + js) % 2 != 0) {{
		return 0;
	}}

	const qnumber je_min = qmax(abs(ja - jb), abs(jc - js));
	const qnumber je_max = qmin(ja + jb, jc + js);
	assert((je_max - je_min) % 2 == 0);
	if (je < je_min || je > je_max) {{
		return 0;
	}}
	if ((ja + jb + je) % 2 != 0) {{
		return 0;
	}}

	const qnumber jf_min = qmax(abs(jb - jc), abs(ja - js));
	const qnumber jf_max = qmin(jb + jc, ja + js);
	assert((jf_max - jf_min) % 2 == 0);
	if (jf < jf_min || jf > jf_max) {{
		return 0;
	}}
	if ((jb + jc + jf) % 2 != 0) {{
		return 0;
	}}

	assert(je_max - je_min == jf_max - jf_min);

	// quantum number ranges in precomputed tables
	assert(ja <= {num_ja - 1});
	assert(jb <= {num_jb - 1});
	assert(jc <= {num_jc - 1});
	assert(js <= {num_js - 1});

	// matrix dimension
	const int n = (je_max - je_min) / 2 + 1;
	assert(n >= 1);

	const int x = (je - je_min) / 2;
	const int y = (jf - jf_min) / 2;
	return su2_recoupling_table[ja][jb][jc][js][x * n + y];
}}
""")

    cfile.close()
    hfile.close()


if __name__ == "__main__":
    generate_su2_recoupling_tables()
